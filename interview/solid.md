# SOLID 원칙에 대한 설명

**SRP: 단일 책임 원칙(Single Responsibility Principle)**

→ 책임이 변경의 축. 책임이 너무 많이 가지고 있으면 결합도가 높아져 다른 책임도 변하는 연쇄적인 변화 발생

* 클래스가 오직 하나의 목적이나 이유로만 변경되어야 한다는 것
* 특정 사용자나 기능 요구사항에 따라 소프트웨어의 변경 요청을 처리하는 역할
* 클래스는 한가지 변화의 이유만 가져야 하며, 이를 통해 변경이 발생했을 때 다른 기능에 영향이 덜 미치도록 설계. → 유지보수 및 이해가 쉬운 코드 작성

**OCP: 개방 폐쇄 원칙(Open-Closed Principle)**

* 확장에는 열려잇고 변경에는 닫혀있음을 강조
  * 확장: 새로운 타입추가 및 기능 추가
  * 폐쇄 : 확장이 일어날 때 상위 레벨의 모듈이 영향을 받지 않아야함 → 모듈의 행동을 쉽게 변경 가능
  * 모듈 : 클래스, 패키지, 라이브러리 등 프로그램을 구성하는 임의의 요소들

**LSP: 리스코브 치환 원칙(Liskov Substitution Principle)**

* `is-a` 로 치환해서 생각해보기
* 서브타입은 어제나 상위 타입으로 교체할 수 있어야함.
* 부모쪽으로 업캐스팅하는 것이 안전함을 보장하기 위해 존재
* 상위 타입의 역할과 행동 규약에서 벗어나면 안됨.
* 만약 하위 타입이 상위 타입에 기대되는 역할을 만족하지 않는다면, 상위 타입을 사용하는 클라이언트 코드에서는 하위 타입이 누구니지 물어봐야하는데 이는 OCP를 어렵게하미 LSP를 위반하는 대표적 사례는 Rectangle 예제.

**ISP: 인터페이스 분리 원칙(Interface Segregation Principle)**

* 클라이언트 입장에서 인터페이스 분리의 필요성을 강조함
*   인터페이스가 비대해지면

    → 같은 인터페이스를 구현하는 클라이언트간의 결합도가 높아짐

    → 특정 클라이언트를 위한 메서드 추가 시, 다른 클라이언트는 구현이 강제되고 변경에 영향
* 사용하지 않지만 의존성을 가지고 있다면 해당 인터페이스가 변경되는 경우에 영향을 받음. → 독립적인 개발과 배포가 불가능
* 사용하는 기능만 제공하도록 인터페이스를 분리해 변경 여파를 최소화 할 수 있음

**DIP: 의존성 역전 원칙(Dependency Inversion Principle)**

*   상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안됨

    → 추상화에 의존해야함

    추상화가 구체적인것에 의존하게되면 추상화를 자유롭게 재사용할 수 없게 되기 때문에
* 의존성 역전 원칙을 통해서 하위 레벨의 모듈은 개발폐쇄원칙을 준수하면서 새로운 타입 추가 가능

> \[참고]
>
> * [\[10분 테코톡\] 클로버의 SOLID](https://youtu.be/7c0tqHLfxlE?si=A67pNJtuql7QsidO)
> * [백명석님 클린 코더스 - SOLID Foundation](https://youtu.be/HIWJ8sF8lO8?si=qzJxDlTYGNH5eRpy)
