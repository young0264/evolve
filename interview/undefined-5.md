# 시스템 간 비동기 연동 방식?

#### \[분리된 시스템 간의 비동기 연동]

* 시스템간 결합도를 낮추고, 시스템의 응답을 기다리지 않으므로 더욱 빨리 사용자의 요청에 응답할 수 있다는 장점.
* 비동기 연동 방식으로 메시징 시스템 활용, 데이터베이스 활용, CDC 활용

**메시징 시스템 활용 방식**

> 두 시스템 사이에 메시징 시스템을 두어 비동기로 연동하는 방식

* 한 시스템에서 메시지를 생성, 메시징 시스템에 송신한 이후, 다른 시스템에서 메시징 시스템으로부터 메시지를 읽어와 메시지를 처리합니다. KafKa, RabbitMQ가 주로 메시징 시스템으로 활용됩니다. 해당 방식은 처리량이 높은 것이 장점
* 하지만, 메시지 유실, 메시지 소비 순서, 트랜잭션에 대한 고민이 추가적으로 필요함.
  *   1개의 트랜잭션 내에 메시지 전송과 데이터베이스 삽입이 존재한다고 했을 때 데이터베이스 삽입이 실패했는데 메시지는 ㅓㄴ송되거나, 데잍어 베이스 삽입은 성공했는데, 메시지 전송이 실패한 경우

      이런 경우 2ㅐㄱ의 작업을 어떻게 원자적으로 처리할 수 있을지 추가적 고민 필요

**데이터 베이스 활용 방식**

> 데이터베이스를 메시징 시스템처럼 사용하는 방법

* 한 시스템에서 데이터베이스 테이블에 필요한 메시지 레코드를 추가하고 연동 시스템이 테이블을 주기적으로 읽음
* 만약 새로운 메시지가 추가되면 연동 시스템은 다른 시스템으로 메시지를 전송함
* 해당 방식은 트랜잭션과 메시지 순서가 보장되며, 메시지 유실에 대한 걱정이 없다는 것이 장점
* 하지만 범용성이 떨어짐. 메시지에 대한 형식이 빈번히 변경될때마다 메시지 레코드에 대한 스키마도 변경해주어야함. 추가적으로 해당 방식은 삭제 정책과 읽기 빈도 등 추가적으로 고민해야할 부분들이 존재함

**CDC(Change Data Capture)**

> 데이터베이스의 변경 사항을 조회하여, 이를 다른 시스템에 전파하는 방식

* 가령 별도의 시스템이 변경 감지 대상 데이터베이스의 바이너리 로그를 조회하여 변경을 전파하도록 구현할 수 있음.
* 트랜잭션이 보장됨, 메시지를 생성하거나 별도로 저장할 필요가 없으니 상대적으로 애플리케이션 로직이 단순하다는 장점이 있음
* 하지만 변경 로그만 존재할뿐 왜 바뀌었는지에 대한 추가적인 정보가 없기 때문에 사용하는데에 제약이 존재할 수 있음.

***

**RDB를 사용하는 애플리케이션에서 전달 방법**

@Transactional 사용하면 AOP를 사용

객체에 proxy객체 하나 싸고있음

@TransactionalEventListener

@Retryable

Transactional Outbox 패턴 적용

RabbitMQ
