---
description: '[250121_화] 캐싱 전략'
---

# 캐싱 전략

#### 캐시?

* 성능 향상과 부하 감소를 목표로함.
* 데이터나 값을 미리 복사해놓는 임시 저장소

#### 캐시의 활용

* Dynamic Programming
  * 이전의 값을 저장할 때
* JPA: 영속성 컨텍스트
  * 내부적 1차 캐시 사용

#### 캐시 전략 패턴

Application, Cache, Database

캐시를 사용하는 양상이 서비스에 큰 영향을 끼치기도함. 캐싱 전략 이해는 중요.

#### Cache Aside(Lazy Loading) 방식에 대해 설명

Cache Aside 방식은 캐시 히트시 캐시에서 데이터를 불러오며, 캐시 미스 발생시 원본 데이터베이스에서 조회하며 반환. 애플리케이션은 캐시 미스가 발생하면 해당 데이터를 캐시에 적재함

해당 방식은 실제 요청된 데이터만 캐시에 저장되므로 불필요한 데이터 캐싱을 줄일 수 있음. 또한 캐싱 문제가 발생한다해도 애플리케이션은 원본 데이터베이스에 직접 접근할 수 있기때문에 서비스가 계속 작동할 수 있는 장점이 있음. 하지만 캐시 미스가 발생하는 경우에만 데이터를 캐시에 적재하기 때문에 원본 데이터베이스와 같은 데이터가 아닐 수도 있으며, 초기에는 대량의 캐시 미스로 인한 데이터베이스 부하가 발생 가능

#### 읽기 전략

**Read Through** 방식

* 먼저 Cache Store에서 조회 → 없으면 Database 조회
* 장점: 캐시, DB간의 데이터 정합성 보장
* 단점 : 캐시가 죽으면 어플리 케이션 문제 발생

#### 캐시 불일치를 해소할 수 있는 쓰기 전략에 대해 설명

\*\*캐시 불일치(Cache Inconsistency)\*\*란 원본 데이터베이스에 저장된 데이터와 캐시에 저장된 데이터가 서로 다른 상황을 의미함. Write Through, Cache Invalidation, Write Behind 방식으로 이러한 캐시 불일치 문제 해결 가능.

**Write Back** 방식

* 장점: 쓰기 횟수 비용을 줄일 수 있음(하나의 insert 문으로 묶어서 데이터 처리)
* 단점: 캐시의 데이터 유실 문제

**Write Through** 방식

* 원본 데이터에 대한 변경분이 생긴 경우, 매번 캐시에 해당 **데이터를 찾아 함께 변경**하는 방식. (**데이터 변경시 즉시 디스크에 기록**)
* 2번 쓰기가 발생, but 캐시는 항상 최신 데이터를 가지고 있음(캐시는 다시 조회되는 경우에 빛을 발휘)
* 무작정 데이터를 갱신하면 저장하는 방식은 리소스 낭비가 될 수 있으니 해당 방식을 사용하는 경우 만료 시간을 사용하는 것이 권장

**Cache Invalidation** 방식

* 원본 데이터에 대한 변경분이 생긴 경우, 캐시 데이터를 만료시키는 방식.
*   Write Through 방식의 단점을 보완한 방식

    캐시에 데이터가 삭제되니 캐시 불일치에 대한 걱정을 하지 않아도 됨.

**Write Behind** 방식

* 원본 데이터에 대한 변경분이 생긴 경우, 캐시를 먼저 업데이트한 이후 추후에 원본 데이터를 변경.
* 디스크 쓰기 작업을 비동기 작업으로 수행하여 성능을 개선할 수 있음
* 원본 데이터와 캐시가 일시적으로 일치하지 않을 수 있어 쓰기 작업이 빈번하며 일시적인 캐시 불일치를 허용하는 서비스에서 유용하게 사용될 수 있음

***

* **DISK에 바로 쓰지 않는 이유?**
  * 디스크는 상대적으로 속도가 느린 I/O
  * 데이터가 자주 변경되는 상황에서 매번 디스크에 데이터를 기록하면 다음과 같은 단점이 생김
    * 쓰기 작업의 비용이 높음
      * 디스크 쓰기는 느린 작업. 매번 디스크에 접근하면 시스템 성능이 저하됨
    * 불필요한 작업 중복
      * 동일한 데이터를 짧은 시간에 여러번 수정하면, 매번 디스크에 쓰는 대신 한번만 쓰는게 효율적임
* springboot application 은 heap이나 stack을 캐시처럼 사용하는 것.
  * JVM 내에 캐시메모리는 없음.
  * 실제 하드웨어 캐시와는 속도차이가 남
* **디스크 대신 캐시에 먼저 쓰는 방식?**
  * 캐시?
    * 캐시는 메모리와 같은 빠른 저장소 → 훨씬 더 빠르게 디스크에 접근 가능
    * 캐시에 먼저 데이터를 기록하고 이후에 디스크에 쓰는 방식을 통해 성능을 최적화 가능
  * 캐시에 먼저 쓰기
    * 사용자가 데이터를 수정하면, 캐시에 먼저 기록
    * 디스크에 기록은 비동기적으로 수행
      * 데이터를 일정 시간마다 **묶어서 디스크에 쓰거나**, 시스템 리소스가 **여유로울 때 수행**
      * 읽기 작업은 최신 데이터를 캐시에서 바로 가져오므로 빠른 응답 가능
  * 읽기 작업은 최신 데이터를 캐시에서 바로 읽어와 빠른 응답 가능.
    * Map/ConcurrentHashMap 등은 JVM 힙 메모리 사용
    * Spring Cache Abstraction은 캐싱 로직을 추상화하여, 캐시 구현에 의존하지 않고 쉽게 캐싱을 사용할 수 있도록 도와줌
      * 내부적으로 ConcurrentHashMap을 캐시 저장소로 사용.

> \[참고]
>
> * [\[10분 테코톡\] 저문, 라온의 Cache & Redis](https://youtu.be/tVZ15cCRAyE?feature=shared)
> * [잘못된 캐싱 전략이 당신의 서비스를 망치고 있습니다](https://maily.so/devpill/posts/8do7dxleogq)
